import { A } from "@mobily/ts-belt";
export declare let Tuple: <T extends [any, ...any]>(v: T) => T;
export declare function modes<X>(xs: X[]): X[];
export declare function recombine<X, Y>(xs: X[], ys: Y[]): [X, Y][];
export declare function append_<T>(xs: T[], x: T): T[];
export declare function groupBy<A>(xs: Array<A>, groupFn: (item: A) => PropertyKey): Record<PropertyKey, [A, ...A[]]>;
export declare function groupBy<A>(groupFn: (item: A) => PropertyKey): (xs: Array<A>) => Record<PropertyKey, [A, ...A[]]>;
export declare function splitBy<T, K extends PropertyKey>(xs: T[], fn: (x: T) => K): T[][];
export declare function reduce1<X>(xs: X[], fn: (z: X, x: X) => X): X;
export declare function concatCappedLeft<T>(n: number, xs1: T[], xs2: T[]): T[];
export declare function concatCappedRight<T>(n: number, xs1: T[], xs2: T[]): T[];
export declare function splitInTwo<T>(xs: T[]): [T[], T[]] | undefined;
export declare function uniqByLatest<X>(xs: X[], uniqFn: (x: X) => string): X[];
export declare function min<T extends string | number>(xs: T[]): T | undefined;
export declare function max<T extends string | number>(xs: T[]): T | undefined;
export declare function transpose2d(array2d: string[][]): string[][];
export declare function splitAt<A>(xs: A[], offset: number): [A[], A[]];
export declare let append: typeof A.append;
export declare let concat: typeof A.concat;
export declare let difference: typeof A.difference;
export declare let drop: typeof A.drop;
export declare function dropWhile<X>(xs: X[], predicate: (x: X) => boolean): X[];
export declare let filter: typeof A.filter;
export declare let find: typeof A.find;
export declare let flat: typeof A.flat;
export declare let flatMap: typeof A.flatMap;
export declare let head: typeof A.head;
export declare let includes: typeof A.includes;
export declare let intersection: typeof A.intersection;
export declare let isEmpty: typeof A.isEmpty;
export declare let isNotEmpty: typeof A.isNotEmpty;
export declare let join: typeof A.join;
export declare let last: typeof A.last;
export declare let map: typeof A.map;
export declare let mapWithIndex: typeof A.mapWithIndex;
export declare let partition: typeof A.partition;
export declare let prepend: typeof A.prepend;
export declare let range: typeof A.range;
export declare let rangeBy: typeof A.rangeBy;
export declare let reduce: typeof A.reduce;
export declare let reject: typeof A.reject;
export declare let removeAt: typeof A.removeAt;
export declare let removeFirst: typeof A.removeFirst;
export declare let repeat: typeof A.repeat;
export declare function replace<X>(xs: X[], fromX: X, toX: X): X[];
export declare let reverse: typeof A.reverse;
export declare let shuffle: typeof A.shuffle;
export declare let sort: typeof A.sort;
export declare let sortBy: typeof A.sortBy;
export declare let splitEvery: typeof A.splitEvery;
export declare let take: typeof A.take;
export declare let takeWhile: typeof A.takeWhile;
export declare let uniq: typeof A.uniq;
export declare let uniqBy: typeof A.uniqBy;
export declare let zip: typeof A.zip;
export declare let zipWith: typeof A.zipWith;
export declare let zipWithIndex: typeof A.zipWithIndex;
